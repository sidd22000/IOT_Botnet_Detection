# -*- coding: utf-8 -*-
"""pcap_webapp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cd72BJ7B5AVh990hpnIF8dkV3SjX3CNw
"""

!pip install -q streamlit
!pip install scapy

# %%writefile app.py
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import csv
import base64

from google.colab import files
from scapy.all import *
import matplotlib.pyplot as plt

from collections import Counter

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

#qbs now adding more tds add this later

st.title('PCAP File Analyser')

st.markdown("""
This app performs simple pcap analysis and provides insights about traffic data along with downloadable reports which saves time !
""")

st.header('Display essentials stats derived from pcap file')
#st.write(pcap name)
#st.dataframe(data)


# Download stats
def filedownload(df):
    csv = df.to_csv(index=False)
    b64 = base64.b64encode(csv.encode()).decode()  # strings <-> bytes conversions
    href = f'<a href="data:file/csv;base64,{b64}" download="pcapstats.csv">Download CSV File</a>'
    return href

st.markdown(filedownload(csv), unsafe_allow_html=True)

# Commented out IPython magic to ensure Python compatibility.
from prettytable import PrettyTable
import numpy as np
# %matplotlib inline
# from scapy.utils import PcapReader
from matplotlib import pyplot as plt
PIE_PLOT_DATA = []
def read_pcap():
  count_UDP = count_TCP = 0
  pcap_read = rdpcap('suspicious.pcap')
  print(pcap_read)
  for pkt in pcap_read:
    if pkt.haslayer(IP):
      if pkt[IP].proto == 17:
        count_UDP += 1
      if pkt[IP].proto ==6:
        count_TCP += 1

  print(count_UDP)
  print(count_TCP)
  PIE_PLOT_DATA.append(count_UDP)
  PIE_PLOT_DATA.append(count_TCP)
  piePlot()

def piePlot():
  DATA_TYPE = ['UDP','TCP']
  explode = (0.1, 0.0)
 
  # Creating color parameters
  colors = ( "indigo", "beige")
 
  # Wedge properties
  wp = { 'linewidth' : 1, 'edgecolor' : "black" }
 
  # Creating autocpt arguments
  def func(pct, allvalues):
    absolute = int(pct / 100.*np.sum(allvalues))
    return "{:.1f}%\n({:d} g)".format(pct, absolute)
 
  # Creating plot
  fig, ax = plt.subplots(figsize =(10, 7))
  wedges, texts, autotexts = ax.pie(PIE_PLOT_DATA,
                                  autopct = lambda pct: func(pct, PIE_PLOT_DATA),
                                  explode = explode,
                                  labels = DATA_TYPE,
                                  shadow = True,
                                  colors = colors,
                                  startangle = 90,
                                  wedgeprops = wp,
                                  textprops = dict(color ="magenta"))
 
  # Adding legend
  ax.legend(wedges, DATA_TYPE,
          title ="Data Types",
          loc ="center left",
          bbox_to_anchor =(1, 0, 0.5, 1))
 
  plt.setp(autotexts, size = 8, weight ="bold")
  ax.set_title("Customizing pie chart")
 
  # show plot
  plt.show()

# def process_src_IP():
#   packets = rdpcap('suspicious.pcap')
#   srcIP=[]
#   for pkt in packets:
#     if IP in pkt:
#       try:
#         srcIP.append(pkt[IP].src)
#         #print(srcIP)
#       except:
#         pass
  
#   cnt=Counter()
#   for ip in srcIP:
#     cnt[ip] += 1
#   xData=[]
#   yData=[]
#   for ip, count in cnt.most_common():
#     xData.append(ip)
#     yData.append(count)

#   table= PrettyTable(["IP", "Count"])
#   for ip, count in cnt.most_common():
#     table.add_row([ip, count])

#   plt.bar(xData,yData)
#   plt.title("Src IP count")
#   plt.xlabel("Src IPs ")
#   plt.ylabel("Number of times it occuered ")
#   plt.xticks(xData, rotation='vertical')
#   plt.show()
  
#   result = []

#   for line in table.splitlines():
#       splitdata = line.split("|")
#       if len(splitdata) == 1:
#           continue  # skip lines with no separators
#       linedata = []
#       for field in splitdata:
#           field = field.strip()
#           if field:
#               linedata.append(field)
#       result.append(linedata)

#       with open('pcapstats.csv', 'wb') as outcsv:
#         writer = csv.writer(outcsv)
#         writer.writerows(result)



def main():
  st.subheader("Upload PCAP")
  pcap_file = st.file_uploader("Upload PCAP", type=["pcap"])
  # process_src_IP()
  read_pcap()



if __name__=='__main__':
  main()

